{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Weather API","text":""},{"location":"#overview","title":"Overview","text":"<p>This Weather Forecast API provides access to weather forecast data. The forecast  data includes features such as wind components and solar radiation levels at specified geographic coordinates. The forecasting process involves predicting atmospheric conditions based on various factors and models. The data provided by this API represents the forecasted state of the atmosphere at different heights above the ground and for various forecast creation times. </p>"},{"location":"#objective","title":"Objective","text":"<p>The primary objective of this API is to provide real-time and historical weather forecast data to enable more efficient energy management, trading, and planning within microgrids and larger gridpool portfolios.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Real-time Weather Forecasting: Access current atmospheric conditions based on  recent data.</li> <li>Historical Data Access: Retrieve past weather forecasts for analysis and trend  prediction.</li> <li>Feature Customization: Choose from a variety of weather features like wind speed,  solar radiation, and more.</li> <li>Geographical Flexibility: Get forecasts for any location specified by latitude and  longitude.</li> </ul>"},{"location":"#example-use-cases","title":"Example Use Cases","text":"<ul> <li>Adjusting the trading of photovoltaic (PV) surplus production based on future  solar radiation forecasts.</li> <li>Feeding excess energy into batteries when low consumption or high production is  forecasted.</li> <li>Dynamic pricing strategies for energy trading based on anticipated weather  conditions.</li> <li>Resource allocation in microgrids for anticipated energy demands, guided by  weather forecasts.</li> <li>Risk assessment and contingency planning for severe weather events.</li> </ul>"},{"location":"#target-audience","title":"Target Audience","text":"<p>This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid electricity flows or trading of energy. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in electrical engineering and systems and/or weather forecast services. </p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Weather API","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You need to make sure you have the <code>git submodules</code> updated:</p> <pre><code>git submodule update --init\n</code></pre>"},{"location":"CONTRIBUTING/#running-protolint","title":"Running protolint","text":"<p>To make sure some common mistakes are avoided and to ensure a consistent style it is recommended to run <code>protolint</code>. After you installed <code>protolint</code>, just run:</p> <pre><code>protolint lint proto\n</code></pre>"},{"location":"CONTRIBUTING/#python-setup","title":"Python setup","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>This will also generate the Python files from the <code>proto/</code> files and leave them in <code>py/</code>, so you can inspect them.</p> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#upgrading-dependencies","title":"Upgrading dependencies","text":"<p>If you want to update the dependency <code>frequenz-api-common</code>, then you need to:</p> <ol> <li>Update the submodule <code>frequenz-api-common</code></li> <li>Update the version of the <code>frequenz-api-common</code> package in <code>pyproject.toml</code></li> </ol> <p>The version of <code>frequenz-api-common</code> used in both places mentioned above should be the same.</p> <p>Here is an example of upgrading the <code>frequenz-api-common</code> dependency to version <code>v0.2.0</code>: <pre><code>ver=\"0.2.0\"\n\ncd submodules/frequenz-api-common\ngit remote update\ngit checkout v${ver}\ncd -\n\nsed s/\"frequenz-api-common == [0-9]\\.[0-9]\\.[0-9]\"/\"frequenz-api-common == ${ver}\"/g -i pyproject.toml\n</code></pre></p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Protobuf API Reference</li> <li>Python API Reference</li> <li>Contributing</li> </ul>"},{"location":"protobuf-reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>api<ul> <li>common<ul> <li>location.proto</li> <li>pagination<ul> <li>pagination_info.proto</li> <li>pagination_params.proto</li> </ul> </li> </ul> </li> <li>weather<ul> <li>weather.proto</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"protobuf-reference/frequenz/api/common/location/","title":"Protocol Documentation","text":""},{"location":"protobuf-reference/frequenz/api/common/location/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>frequenz/api/common/location.proto</p> <ul> <li>Location</li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protobuf-reference/frequenz/api/common/location/#frequenzapicommonlocationproto","title":"frequenz/api/common/location.proto","text":""},{"location":"protobuf-reference/frequenz/api/common/location/#location","title":"Location","text":"<p>A pair of geographical co-ordinates, representing the location of a place.</p> Field Type Label Description latitude float Latitude ranges from -90 (South) to 90 (North) longitude float Longitude ranges from -180 (West) to 180 (East) country_code string Country ISO 3166-1 Alpha 2"},{"location":"protobuf-reference/frequenz/api/common/location/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"protobuf-reference/frequenz/api/common/pagination/pagination_info/","title":"Protocol Documentation","text":""},{"location":"protobuf-reference/frequenz/api/common/pagination/pagination_info/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>frequenz/api/common/pagination/pagination_info.proto</p> <ul> <li>PaginationInfo</li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protobuf-reference/frequenz/api/common/pagination/pagination_info/#frequenzapicommonpaginationpagination_infoproto","title":"frequenz/api/common/pagination/pagination_info.proto","text":""},{"location":"protobuf-reference/frequenz/api/common/pagination/pagination_info/#paginationinfo","title":"PaginationInfo","text":"<p>A message providing metadata about paginated list results. The PaginationInfo message delivers metadata concerning the paginated list results and should be appended to the response message of a list request. The total_items field must be set to the total count of items that adhere to the filter criteria defined in the request. The next_page_token field should be populated with the token to be used in the subsequent request to fetch the next page of results. If there are no additional results, the next_page_token field should be omitted.</p> Field Type Label Description total_items uint32 The total number of items that match the filter criteria defined in the request. next_page_token string optional Token for retrieving the next set of results."},{"location":"protobuf-reference/frequenz/api/common/pagination/pagination_info/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"protobuf-reference/frequenz/api/common/pagination/pagination_params/","title":"Protocol Documentation","text":""},{"location":"protobuf-reference/frequenz/api/common/pagination/pagination_params/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>frequenz/api/common/pagination/pagination_params.proto</p> <ul> <li>PaginationParams</li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protobuf-reference/frequenz/api/common/pagination/pagination_params/#frequenzapicommonpaginationpagination_paramsproto","title":"frequenz/api/common/pagination/pagination_params.proto","text":""},{"location":"protobuf-reference/frequenz/api/common/pagination/pagination_params/#paginationparams","title":"PaginationParams","text":"<p>A message defining parameters for paginating list requests. It can be appended to a request message to specify the desired page of results and the maximum number of results per page. For initial requests (requesting the first page), the page_token should not be provided. For subsequent requests (requesting any page after the first), the next_page_token from the previous responses PaginationInfo must be supplied. The page_size should only be specified in the initial request and will be disregarded in subsequent requests.</p> Field Type Label Description page_size uint32 optional The maximum number of results to be returned per request. page_token string optional The token identifying a specific page of the list results."},{"location":"protobuf-reference/frequenz/api/common/pagination/pagination_params/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"protobuf-reference/frequenz/api/weather/weather/","title":"Protocol Documentation","text":""},{"location":"protobuf-reference/frequenz/api/weather/weather/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>frequenz/api/weather/weather.proto</p> <ul> <li>GetHistoricalWeatherForecastRequest</li> <li>GetHistoricalWeatherForecastResponse</li> <li>LocationForecast</li> <li>LocationForecast.Forecasts</li> <li>LocationForecast.Forecasts.FeatureForecast</li> <li>ReceiveLiveWeatherForecastRequest</li> <li> <p>ReceiveLiveWeatherForecastResponse</p> </li> <li> <p>ForecastFeature</p> </li> <li> <p>WeatherForecastService</p> </li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protobuf-reference/frequenz/api/weather/weather/#frequenzapiweatherweatherproto","title":"frequenz/api/weather/weather.proto","text":""},{"location":"protobuf-reference/frequenz/api/weather/weather/#gethistoricalweatherforecastrequest","title":"GetHistoricalWeatherForecastRequest","text":"<p>The <code>GetHistoricalWeatherForecastRequest</code> message defines parameters for retrieving historical weather forecasts, targeting a specific location and time period, with designated features.</p> Field Type Label Description locations Location repeated The locations for which the forecast is being requested. The maximum number of locations that can be requested is 50. If the request exceeds this limit, the API will respond with an error. features ForecastFeature repeated List of required features. If none are specified, all available features will be returned. start_ts google.protobuf.Timestamp The UTC timestamp indicating the start of the requested historical forecast period. end_ts google.protobuf.Timestamp The UTC timestamp indicating the end of the requested historical forecast period. pagination_params PaginationParams The parameters define the 'page_size' and the 'page_token'. An inital query of a request will omit the 'page_token'. Subsequent queries of the same request must include the 'page_token' from the previous response. <p></p>"},{"location":"protobuf-reference/frequenz/api/weather/weather/#gethistoricalweatherforecastresponse","title":"GetHistoricalWeatherForecastResponse","text":"<p>The message encapsulates a collection of historical weather forecasts, each corresponding to a requested location.</p> Field Type Label Description location_forecasts LocationForecast repeated pagination_info PaginationInfo The pagination_info contains the number of 'total_items' in the response and the 'next_page_token' for the subsequent query of the request. It is omitted in the last response. <p></p>"},{"location":"protobuf-reference/frequenz/api/weather/weather/#locationforecast","title":"LocationForecast","text":"<p>The <code>ForecastResponse</code> message  provides a structured format for representing forecast data for a specific location, including UTC timestamps for validity and creation.</p> Field Type Label Description forecasts LocationForecast.Forecasts repeated Weather forecasts. location Location The location for which the weather data is returned. creation_ts google.protobuf.Timestamp The UTC timestamp indicating when the forecast was originally created. <p></p>"},{"location":"protobuf-reference/frequenz/api/weather/weather/#locationforecastforecasts","title":"LocationForecast.Forecasts","text":"<p>Holds all weather features forecast for a certain point in time.</p> Field Type Label Description valid_at_ts google.protobuf.Timestamp The UTC timestamp for which the features in this entry are valid for. features LocationForecast.Forecasts.FeatureForecast repeated All requested weather features. <p></p>"},{"location":"protobuf-reference/frequenz/api/weather/weather/#locationforecastforecastsfeatureforecast","title":"LocationForecast.Forecasts.FeatureForecast","text":"<p>Holds the forecast for a single weather feature.</p> Field Type Label Description feature ForecastFeature value float Value of the feature. Unit depends on the feature (e.g., m/s for wind speed, W/m\u00b2 for radiation). Details can be found in the ForecastFeature enum under each feature. <p></p>"},{"location":"protobuf-reference/frequenz/api/weather/weather/#receiveliveweatherforecastrequest","title":"ReceiveLiveWeatherForecastRequest","text":"<p>The <code>ReceiveLiveWeatherForecastRequest</code> message defines parameters for requesting live weather forecasts for a specified location, with designated features.</p> Field Type Label Description locations Location repeated The locations for which the forecast is being requested. The maximum number of locations that can be requested is 50. If the request exceeds this limit, the API will respond with an error. features ForecastFeature repeated List of required features. If none are specified, all available features will be streamed. <p></p>"},{"location":"protobuf-reference/frequenz/api/weather/weather/#receiveliveweatherforecastresponse","title":"ReceiveLiveWeatherForecastResponse","text":"<p>The message encapsulates a collection of live weather forecasts, each corresponding to a requested location.</p> Field Type Label Description location_forecasts LocationForecast repeated <p></p>"},{"location":"protobuf-reference/frequenz/api/weather/weather/#forecastfeature","title":"ForecastFeature","text":"<p>Weather features (e.g. wind speeds or solar radiation) available for query through the API.</p> Name Number Description FORECAST_FEATURE_UNSPECIFIED 0 Default value. When used, the API responds with all features listed below. FORECAST_FEATURE_TEMPERATURE_2_METRE 1 Temperature at 2 m altitude. It is the temperature of the air at a height of 2 metres above the surface of land, sea or in-land waters. Measured in Kelvin. To convert to Celsius, subtract 273.15. FORECAST_FEATURE_U_WIND_COMPONENT_100_METRE 2 Eastward component of the wind at 100 m altitude. It is the horizontal speed of air moving towards the east, at a height of 100 metres above the surface of the Earth. A positive value indicates eastward wind, and a negative value indicates westward wind. Typical range is -20 to 20 m/s. Measured in m/s. FORECAST_FEATURE_V_WIND_COMPONENT_100_METRE 3 Northward component wind at 100 m altitude. It is the horizontal speed of air moving towards the north, at a height of 100 metres above the surface of the Earth. A positive value indicates northward wind, and a negative value indicates southward wind. Typical range is -20 to 20 m/s. Measured in m/s. FORECAST_FEATURE_U_WIND_COMPONENT_10_METRE 4 Eastward component wind at 10 m altitude. It is the horizontal speed of air moving towards the east, at a height of 10 metres above the surface of the Earth. A positive value indicates eastward wind, and a negative value indicates westward wind. Typical values are smaller than their 100 m counterparts since it is stronger influenced by local terrain, vegetation and buildings. Measured in m/s. FORECAST_FEATURE_V_WIND_COMPONENT_10_METRE 5 Northward component wind at 10 m altitude. It is the horizontal speed of air moving towards the north, at a height of 100 metres above the surface of the Earth. A positive value indicates northward wind, and a negative value indicates southward wind. Typical values are smaller than their 100 m counterparts since it is stronger influenced by local terrain, vegetation and buildings. Measured in m/s. FORECAST_FEATURE_SURFACE_SOLAR_RADIATION_DOWNWARDS 6 Amount of solar radiation (shortwave radiation, direct and diffused) that reaches a horizontal plane at the surface of the Earth. Measured in W/m\u00b2. FORECAST_FEATURE_SURFACE_NET_SOLAR_RADIATION 7 Amount of solar radiation (shortwave radiation, direct and diffused) that reaches a horizontal plane at the surface of the Earth minus the amount reflected by the Earth's surface (which is governed by the albedo). Measured in W/m\u00b2. <p></p>"},{"location":"protobuf-reference/frequenz/api/weather/weather/#weatherforecastservice","title":"WeatherForecastService","text":"<p>Service provides operations related to retrieving weather forecasts for locations.</p> <p>The forecasts are updated regularly, and the service will stream the latest available data unless a specific time range is requested.</p> <p>Note</p> <p>Weather forecasts are inherently uncertain and actual conditions may vary. Use the data responsibly.</p> Method Name Request Type Response Type Description GetHistoricalWeatherForecast GetHistoricalWeatherForecastRequest GetHistoricalWeatherForecastResponse Returns historical weather forecast features for a geo location for a specified time range. ReceiveLiveWeatherForecast ReceiveLiveWeatherForecastRequest ReceiveLiveWeatherForecastResponse stream Streams live weather forecast features for a geo location as they become available. Initially, the most recent forecast will be streamed."},{"location":"protobuf-reference/frequenz/api/weather/weather/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"python-reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>api<ul> <li>common<ul> <li>location_pb2</li> <li>location_pb2_grpc</li> <li>pagination<ul> <li>pagination_info_pb2</li> <li>pagination_info_pb2_grpc</li> <li>pagination_params_pb2</li> <li>pagination_params_pb2_grpc</li> </ul> </li> </ul> </li> <li>weather<ul> <li>weather_pb2</li> <li>weather_pb2_grpc</li> </ul> </li> </ul> </li> <li>client<ul> <li>weather</li> </ul> </li> </ul> </li> </ul>"},{"location":"python-reference/frequenz/api/common/location_pb2/","title":"location_pb2","text":""},{"location":"python-reference/frequenz/api/common/location_pb2/#frequenz.api.common.location_pb2","title":"frequenz.api.common.location_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"python-reference/frequenz/api/common/location_pb2/#frequenz.api.common.location_pb2-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/common/location_pb2/#frequenz.api.common.location_pb2.Location","title":"frequenz.api.common.location_pb2.Location","text":"<p>             Bases: <code>Message</code></p> <p>A pair of geographical co-ordinates, representing the location of a place.</p> Source code in <code>frequenz/api/common/location_pb2.py</code> <pre><code>  DESCRIPTOR._options = None\n  _globals['_LOCATION']._serialized_start=71\n  _globals['_LOCATION']._serialized_end=140\n# @@protoc_insertion_point(module_scope)\n</code></pre>"},{"location":"python-reference/frequenz/api/common/location_pb2/#frequenz.api.common.location_pb2.Location-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/common/location_pb2/#frequenz.api.common.location_pb2.Location.country_code","title":"country_code  <code>instance-attribute</code>","text":"<pre><code>country_code: builtins.str\n</code></pre> <p>Country ISO 3166-1 Alpha 2</p>"},{"location":"python-reference/frequenz/api/common/location_pb2/#frequenz.api.common.location_pb2.Location.latitude","title":"latitude  <code>instance-attribute</code>","text":"<pre><code>latitude: builtins.float\n</code></pre> <p>Latitude ranges from -90 (South) to 90 (North)</p>"},{"location":"python-reference/frequenz/api/common/location_pb2/#frequenz.api.common.location_pb2.Location.longitude","title":"longitude  <code>instance-attribute</code>","text":"<pre><code>longitude: builtins.float\n</code></pre> <p>Longitude ranges from -180 (West) to 180 (East)</p>"},{"location":"python-reference/frequenz/api/common/location_pb2_grpc/","title":"location_pb2_grpc","text":""},{"location":"python-reference/frequenz/api/common/location_pb2_grpc/#frequenz.api.common.location_pb2_grpc","title":"frequenz.api.common.location_pb2_grpc","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"python-reference/frequenz/api/common/pagination/pagination_info_pb2/","title":"pagination_info_pb2","text":""},{"location":"python-reference/frequenz/api/common/pagination/pagination_info_pb2/#frequenz.api.common.pagination.pagination_info_pb2","title":"frequenz.api.common.pagination.pagination_info_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"python-reference/frequenz/api/common/pagination/pagination_info_pb2/#frequenz.api.common.pagination.pagination_info_pb2-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/common/pagination/pagination_info_pb2/#frequenz.api.common.pagination.pagination_info_pb2.PaginationInfo","title":"frequenz.api.common.pagination.pagination_info_pb2.PaginationInfo","text":"<p>             Bases: <code>Message</code></p> <p>A message providing metadata about paginated list results. The PaginationInfo message delivers metadata concerning the paginated list results and should be appended to the response message of a list request. The total_items field must be set to the total count of items that adhere to the filter criteria defined in the request. The next_page_token field should be populated with the token to be used in the subsequent request to fetch the next page of results. If there are no additional results, the next_page_token field should be omitted.</p> Source code in <code>frequenz/api/common/pagination/pagination_info_pb2.py</code> <pre><code>  DESCRIPTOR._options = None\n  _globals['_PAGINATIONINFO']._serialized_start=89\n  _globals['_PAGINATIONINFO']._serialized_end=176\n# @@protoc_insertion_point(module_scope)\n</code></pre>"},{"location":"python-reference/frequenz/api/common/pagination/pagination_info_pb2/#frequenz.api.common.pagination.pagination_info_pb2.PaginationInfo-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/common/pagination/pagination_info_pb2/#frequenz.api.common.pagination.pagination_info_pb2.PaginationInfo.next_page_token","title":"next_page_token  <code>instance-attribute</code>","text":"<pre><code>next_page_token: builtins.str\n</code></pre> <p>Token for retrieving the next set of results.</p>"},{"location":"python-reference/frequenz/api/common/pagination/pagination_info_pb2/#frequenz.api.common.pagination.pagination_info_pb2.PaginationInfo.total_items","title":"total_items  <code>instance-attribute</code>","text":"<pre><code>total_items: builtins.int\n</code></pre> <p>The total number of items that match the filter criteria defined in the request.</p>"},{"location":"python-reference/frequenz/api/common/pagination/pagination_info_pb2_grpc/","title":"pagination_info_pb2_grpc","text":""},{"location":"python-reference/frequenz/api/common/pagination/pagination_info_pb2_grpc/#frequenz.api.common.pagination.pagination_info_pb2_grpc","title":"frequenz.api.common.pagination.pagination_info_pb2_grpc","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"python-reference/frequenz/api/common/pagination/pagination_params_pb2/","title":"pagination_params_pb2","text":""},{"location":"python-reference/frequenz/api/common/pagination/pagination_params_pb2/#frequenz.api.common.pagination.pagination_params_pb2","title":"frequenz.api.common.pagination.pagination_params_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"python-reference/frequenz/api/common/pagination/pagination_params_pb2/#frequenz.api.common.pagination.pagination_params_pb2-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/common/pagination/pagination_params_pb2/#frequenz.api.common.pagination.pagination_params_pb2.PaginationParams","title":"frequenz.api.common.pagination.pagination_params_pb2.PaginationParams","text":"<p>             Bases: <code>Message</code></p> <p>A message defining parameters for paginating list requests. It can be appended to a request message to specify the desired page of results and the maximum number of results per page. For initial requests (requesting the first page), the page_token should not be provided. For subsequent requests (requesting any page after the first), the next_page_token from the previous responses PaginationInfo must be supplied. The page_size should only be specified in the initial request and will be disregarded in subsequent requests.</p> Source code in <code>frequenz/api/common/pagination/pagination_params_pb2.py</code> <pre><code>  _globals['_PAGINATIONPARAMS']._serialized_start=91\n  _globals['_PAGINATIONPARAMS']._serialized_end=187\n# @@protoc_insertion_point(module_scope)\n</code></pre>"},{"location":"python-reference/frequenz/api/common/pagination/pagination_params_pb2/#frequenz.api.common.pagination.pagination_params_pb2.PaginationParams-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/common/pagination/pagination_params_pb2/#frequenz.api.common.pagination.pagination_params_pb2.PaginationParams.page_size","title":"page_size  <code>instance-attribute</code>","text":"<pre><code>page_size: builtins.int\n</code></pre> <p>The maximum number of results to be returned per request.</p>"},{"location":"python-reference/frequenz/api/common/pagination/pagination_params_pb2/#frequenz.api.common.pagination.pagination_params_pb2.PaginationParams.page_token","title":"page_token  <code>instance-attribute</code>","text":"<pre><code>page_token: builtins.str\n</code></pre> <p>The token identifying a specific page of the list results.</p>"},{"location":"python-reference/frequenz/api/common/pagination/pagination_params_pb2_grpc/","title":"pagination_params_pb2_grpc","text":""},{"location":"python-reference/frequenz/api/common/pagination/pagination_params_pb2_grpc/#frequenz.api.common.pagination.pagination_params_pb2_grpc","title":"frequenz.api.common.pagination.pagination_params_pb2_grpc","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"python-reference/frequenz/api/weather/","title":"Index","text":""},{"location":"python-reference/frequenz/api/weather/#frequenz.api.weather","title":"frequenz.api.weather","text":"<p>Protobuf spec for the weather API.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/","title":"weather_pb2","text":""},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2","title":"frequenz.api.weather.weather_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.FORECAST_FEATURE_SURFACE_NET_SOLAR_RADIATION","title":"frequenz.api.weather.weather_pb2.FORECAST_FEATURE_SURFACE_NET_SOLAR_RADIATION  <code>module-attribute</code>","text":"<pre><code>FORECAST_FEATURE_SURFACE_NET_SOLAR_RADIATION: ForecastFeature.ValueType\n</code></pre> <p>Amount of solar radiation (shortwave radiation, direct and diffused) that reaches a horizontal plane at the surface of the Earth minus the amount reflected by the Earth's surface (which is governed by the albedo). Measured in W/m\u00b2.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.FORECAST_FEATURE_SURFACE_SOLAR_RADIATION_DOWNWARDS","title":"frequenz.api.weather.weather_pb2.FORECAST_FEATURE_SURFACE_SOLAR_RADIATION_DOWNWARDS  <code>module-attribute</code>","text":"<pre><code>FORECAST_FEATURE_SURFACE_SOLAR_RADIATION_DOWNWARDS: ForecastFeature.ValueType\n</code></pre> <p>Amount of solar radiation (shortwave radiation, direct and diffused) that reaches a horizontal plane at the surface of the Earth. Measured in W/m\u00b2.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.FORECAST_FEATURE_TEMPERATURE_2_METRE","title":"frequenz.api.weather.weather_pb2.FORECAST_FEATURE_TEMPERATURE_2_METRE  <code>module-attribute</code>","text":"<pre><code>FORECAST_FEATURE_TEMPERATURE_2_METRE: ForecastFeature.ValueType\n</code></pre> <p>Temperature at 2 m altitude. It is the temperature of the air at a height of 2 metres above the surface of land, sea or in-land waters. Measured in Kelvin. To convert to Celsius, subtract 273.15.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.FORECAST_FEATURE_UNSPECIFIED","title":"frequenz.api.weather.weather_pb2.FORECAST_FEATURE_UNSPECIFIED  <code>module-attribute</code>","text":"<pre><code>FORECAST_FEATURE_UNSPECIFIED: ForecastFeature.ValueType\n</code></pre> <p>Default value. When used, the API responds with all features listed below.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.FORECAST_FEATURE_U_WIND_COMPONENT_100_METRE","title":"frequenz.api.weather.weather_pb2.FORECAST_FEATURE_U_WIND_COMPONENT_100_METRE  <code>module-attribute</code>","text":"<pre><code>FORECAST_FEATURE_U_WIND_COMPONENT_100_METRE: ForecastFeature.ValueType\n</code></pre> <p>Eastward component of the wind at 100 m altitude. It is the horizontal speed of air moving towards the east, at a height of 100 metres above the surface of the Earth. A positive value indicates eastward wind, and a negative value indicates westward wind. Typical range is -20 to 20 m/s. Measured in m/s.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.FORECAST_FEATURE_U_WIND_COMPONENT_10_METRE","title":"frequenz.api.weather.weather_pb2.FORECAST_FEATURE_U_WIND_COMPONENT_10_METRE  <code>module-attribute</code>","text":"<pre><code>FORECAST_FEATURE_U_WIND_COMPONENT_10_METRE: ForecastFeature.ValueType\n</code></pre> <p>Eastward component wind at 10 m altitude. It is the horizontal speed of air moving towards the east, at a height of 10 metres above the surface of the Earth. A positive value indicates eastward wind, and a negative value indicates westward wind. Typical values are smaller than their 100 m counterparts since it is stronger influenced by local terrain, vegetation and buildings. Measured in m/s.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.FORECAST_FEATURE_V_WIND_COMPONENT_100_METRE","title":"frequenz.api.weather.weather_pb2.FORECAST_FEATURE_V_WIND_COMPONENT_100_METRE  <code>module-attribute</code>","text":"<pre><code>FORECAST_FEATURE_V_WIND_COMPONENT_100_METRE: ForecastFeature.ValueType\n</code></pre> <p>Northward component wind at 100 m altitude. It is the horizontal speed of air moving towards the north, at a height of 100 metres above the surface of the Earth. A positive value indicates northward wind, and a negative value indicates southward wind. Typical range is -20 to 20 m/s. Measured in m/s.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.FORECAST_FEATURE_V_WIND_COMPONENT_10_METRE","title":"frequenz.api.weather.weather_pb2.FORECAST_FEATURE_V_WIND_COMPONENT_10_METRE  <code>module-attribute</code>","text":"<pre><code>FORECAST_FEATURE_V_WIND_COMPONENT_10_METRE: ForecastFeature.ValueType\n</code></pre> <p>Northward component wind at 10 m altitude. It is the horizontal speed of air moving towards the north, at a height of 100 metres above the surface of the Earth. A positive value indicates northward wind, and a negative value indicates southward wind. Typical values are smaller than their 100 m counterparts since it is stronger influenced by local terrain, vegetation and buildings. Measured in m/s.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.ForecastFeature","title":"frequenz.api.weather.weather_pb2.ForecastFeature","text":"<p>             Bases: <code>_ForecastFeature</code></p> <p>Weather features (e.g. wind speeds or solar radiation) available for query through the API.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.GetHistoricalWeatherForecastRequest","title":"frequenz.api.weather.weather_pb2.GetHistoricalWeatherForecastRequest","text":"<p>             Bases: <code>Message</code></p> <p>The <code>GetHistoricalWeatherForecastRequest</code> message defines parameters for retrieving historical weather forecasts, targeting a specific location and time period, with designated features.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.GetHistoricalWeatherForecastRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.GetHistoricalWeatherForecastRequest.end_ts","title":"end_ts  <code>property</code>","text":"<pre><code>end_ts: google.protobuf.timestamp_pb2.Timestamp\n</code></pre> <p>The UTC timestamp indicating the end of the requested historical forecast period.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.GetHistoricalWeatherForecastRequest.features","title":"features  <code>property</code>","text":"<pre><code>features: google.protobuf.internal.containers.RepeatedScalarFieldContainer[\n    global___ForecastFeature.ValueType\n]\n</code></pre> <p>List of required features. If none are specified, all available features will be returned.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.GetHistoricalWeatherForecastRequest.locations","title":"locations  <code>property</code>","text":"<pre><code>locations: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[\n    frequenz.api.common.location_pb2.Location\n]\n</code></pre> <p>The locations for which the forecast is being requested. The maximum number of locations that can be requested is 50. If the request exceeds this limit, the API will respond with an error.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.GetHistoricalWeatherForecastRequest.pagination_params","title":"pagination_params  <code>property</code>","text":"<pre><code>pagination_params: frequenz.api.common.pagination.pagination_params_pb2.PaginationParams\n</code></pre> <p>The parameters define the 'page_size' and the 'page_token'. An inital query of a request will omit the 'page_token'. Subsequent queries of the same request must include the 'page_token' from the previous response.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.GetHistoricalWeatherForecastRequest.start_ts","title":"start_ts  <code>property</code>","text":"<pre><code>start_ts: google.protobuf.timestamp_pb2.Timestamp\n</code></pre> <p>The UTC timestamp indicating the start of the requested historical forecast period.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.GetHistoricalWeatherForecastResponse","title":"frequenz.api.weather.weather_pb2.GetHistoricalWeatherForecastResponse","text":"<p>             Bases: <code>Message</code></p> <p>The message encapsulates a collection of historical weather forecasts, each corresponding to a requested location.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.GetHistoricalWeatherForecastResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.GetHistoricalWeatherForecastResponse.pagination_info","title":"pagination_info  <code>property</code>","text":"<pre><code>pagination_info: frequenz.api.common.pagination.pagination_info_pb2.PaginationInfo\n</code></pre> <p>The pagination_info contains the number of 'total_items' in the response and the 'next_page_token' for the subsequent query of the request. It is omitted in the last response.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.LocationForecast","title":"frequenz.api.weather.weather_pb2.LocationForecast","text":"<p>             Bases: <code>Message</code></p> <p>The <code>ForecastResponse</code> message  provides a structured format for representing forecast data for a specific location, including UTC timestamps for validity and creation.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.LocationForecast-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.LocationForecast.creation_ts","title":"creation_ts  <code>property</code>","text":"<pre><code>creation_ts: google.protobuf.timestamp_pb2.Timestamp\n</code></pre> <p>The UTC timestamp indicating when the forecast was originally created.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.LocationForecast.forecasts","title":"forecasts  <code>property</code>","text":"<pre><code>forecasts: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[\n    global___LocationForecast.Forecasts\n]\n</code></pre> <p>Weather forecasts.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.LocationForecast.location","title":"location  <code>property</code>","text":"<pre><code>location: frequenz.api.common.location_pb2.Location\n</code></pre> <p>The location for which the weather data is returned.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.LocationForecast-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.LocationForecast.Forecasts","title":"Forecasts","text":"<p>             Bases: <code>Message</code></p> <p>Holds all weather features forecast for a certain point in time.</p> Attributes\u00a4 features <code>property</code> \u00a4 <pre><code>features: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[\n    global___LocationForecast.Forecasts.FeatureForecast\n]\n</code></pre> <p>All requested weather features.</p> valid_at_ts <code>property</code> \u00a4 <pre><code>valid_at_ts: google.protobuf.timestamp_pb2.Timestamp\n</code></pre> <p>The UTC timestamp for which the features in this entry are valid for.</p> Classes\u00a4 FeatureForecast \u00a4 <p>             Bases: <code>Message</code></p> <p>Holds the forecast for a single weather feature.</p> Attributes\u00a4 value <code>instance-attribute</code> \u00a4 <pre><code>value: builtins.float\n</code></pre> <p>Value of the feature. Unit depends on the feature (e.g., m/s for wind speed, W/m\u00b2 for radiation). Details can be found in the ForecastFeature enum under each feature.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.ReceiveLiveWeatherForecastRequest","title":"frequenz.api.weather.weather_pb2.ReceiveLiveWeatherForecastRequest","text":"<p>             Bases: <code>Message</code></p> <p>The <code>ReceiveLiveWeatherForecastRequest</code> message defines parameters for requesting live weather forecasts for a specified location, with designated features.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.ReceiveLiveWeatherForecastRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.ReceiveLiveWeatherForecastRequest.features","title":"features  <code>property</code>","text":"<pre><code>features: google.protobuf.internal.containers.RepeatedScalarFieldContainer[\n    global___ForecastFeature.ValueType\n]\n</code></pre> <p>List of required features. If none are specified, all available features will be streamed.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.ReceiveLiveWeatherForecastRequest.locations","title":"locations  <code>property</code>","text":"<pre><code>locations: google.protobuf.internal.containers.RepeatedCompositeFieldContainer[\n    frequenz.api.common.location_pb2.Location\n]\n</code></pre> <p>The locations for which the forecast is being requested. The maximum number of locations that can be requested is 50. If the request exceeds this limit, the API will respond with an error.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2/#frequenz.api.weather.weather_pb2.ReceiveLiveWeatherForecastResponse","title":"frequenz.api.weather.weather_pb2.ReceiveLiveWeatherForecastResponse","text":"<p>             Bases: <code>Message</code></p> <p>The message encapsulates a collection of live weather forecasts, each corresponding to a requested location.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2_grpc/","title":"weather_pb2_grpc","text":""},{"location":"python-reference/frequenz/api/weather/weather_pb2_grpc/#frequenz.api.weather.weather_pb2_grpc","title":"frequenz.api.weather.weather_pb2_grpc","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2_grpc/#frequenz.api.weather.weather_pb2_grpc-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/weather/weather_pb2_grpc/#frequenz.api.weather.weather_pb2_grpc.WeatherForecastService","title":"frequenz.api.weather.weather_pb2_grpc.WeatherForecastService","text":"<p>             Bases: <code>object</code></p> <p>Service provides operations related to retrieving weather forecasts for locations.</p> <p>The forecasts are updated regularly, and the service will stream the latest available data unless a specific time range is requested.</p> <p>Note</p> <p>Weather forecasts are inherently uncertain and actual conditions may vary. Use the data responsibly.</p> Source code in <code>frequenz/api/weather/weather_pb2_grpc.py</code> <pre><code>class WeatherForecastService(object):\n    \"\"\"Service provides operations related to retrieving weather forecasts for\n    locations.\n\n    The forecasts are updated regularly, and the service will stream the latest\n    available data unless a specific time range is requested.\n    !!! note\n    Weather forecasts are inherently uncertain and actual conditions may\n    vary. Use the data responsibly.\n    \"\"\"\n\n    @staticmethod\n    def GetHistoricalWeatherForecast(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.weatherforecast.v1.WeatherForecastService/GetHistoricalWeatherForecast',\n            frequenz_dot_api_dot_weather_dot_weather__pb2.GetHistoricalWeatherForecastRequest.SerializeToString,\n            frequenz_dot_api_dot_weather_dot_weather__pb2.GetHistoricalWeatherForecastResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ReceiveLiveWeatherForecast(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_stream(request, target, '/frequenz.api.weatherforecast.v1.WeatherForecastService/ReceiveLiveWeatherForecast',\n            frequenz_dot_api_dot_weather_dot_weather__pb2.ReceiveLiveWeatherForecastRequest.SerializeToString,\n            frequenz_dot_api_dot_weather_dot_weather__pb2.ReceiveLiveWeatherForecastResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n</code></pre>"},{"location":"python-reference/frequenz/api/weather/weather_pb2_grpc/#frequenz.api.weather.weather_pb2_grpc.WeatherForecastServiceAsyncStub","title":"frequenz.api.weather.weather_pb2_grpc.WeatherForecastServiceAsyncStub","text":"<p>Service provides operations related to retrieving weather forecasts for locations.</p> <p>The forecasts are updated regularly, and the service will stream the latest available data unless a specific time range is requested.</p> <p>Note</p> <p>Weather forecasts are inherently uncertain and actual conditions may vary. Use the data responsibly.</p> Source code in <code>frequenz/api/weather/weather_pb2_grpc.py</code> <pre><code>        raise NotImplementedError('Method not implemented!')\n\n    def ReceiveLiveWeatherForecast(self, request, context):\n        \"\"\"Streams live weather forecast features for a geo location as they become\n        available. Initially, the most recent forecast will be streamed.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n\ndef add_WeatherForecastServiceServicer_to_server(servicer, server):\n    rpc_method_handlers = {\n            'GetHistoricalWeatherForecast': grpc.unary_unary_rpc_method_handler(\n                    servicer.GetHistoricalWeatherForecast,\n                    request_deserializer=frequenz_dot_api_dot_weather_dot_weather__pb2.GetHistoricalWeatherForecastRequest.FromString,\n                    response_serializer=frequenz_dot_api_dot_weather_dot_weather__pb2.GetHistoricalWeatherForecastResponse.SerializeToString,\n            ),\n            'ReceiveLiveWeatherForecast': grpc.unary_stream_rpc_method_handler(\n                    servicer.ReceiveLiveWeatherForecast,\n                    request_deserializer=frequenz_dot_api_dot_weather_dot_weather__pb2.ReceiveLiveWeatherForecastRequest.FromString,\n                    response_serializer=frequenz_dot_api_dot_weather_dot_weather__pb2.ReceiveLiveWeatherForecastResponse.SerializeToString,\n            ),\n    }\n    generic_handler = grpc.method_handlers_generic_handler(\n</code></pre>"},{"location":"python-reference/frequenz/api/weather/weather_pb2_grpc/#frequenz.api.weather.weather_pb2_grpc.WeatherForecastServiceAsyncStub-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/weather/weather_pb2_grpc/#frequenz.api.weather.weather_pb2_grpc.WeatherForecastServiceAsyncStub.GetHistoricalWeatherForecast","title":"GetHistoricalWeatherForecast  <code>instance-attribute</code>","text":"<pre><code>GetHistoricalWeatherForecast: grpc.aio.UnaryUnaryMultiCallable[\n    frequenz.api.weather.weather_pb2.GetHistoricalWeatherForecastRequest,\n    frequenz.api.weather.weather_pb2.GetHistoricalWeatherForecastResponse,\n]\n</code></pre> <p>Returns historical weather forecast features for a geo location for a specified time range.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2_grpc/#frequenz.api.weather.weather_pb2_grpc.WeatherForecastServiceAsyncStub.ReceiveLiveWeatherForecast","title":"ReceiveLiveWeatherForecast  <code>instance-attribute</code>","text":"<pre><code>ReceiveLiveWeatherForecast: grpc.aio.UnaryStreamMultiCallable[\n    frequenz.api.weather.weather_pb2.ReceiveLiveWeatherForecastRequest,\n    frequenz.api.weather.weather_pb2.ReceiveLiveWeatherForecastResponse,\n]\n</code></pre> <p>Streams live weather forecast features for a geo location as they become available. Initially, the most recent forecast will be streamed.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2_grpc/#frequenz.api.weather.weather_pb2_grpc.WeatherForecastServiceServicer","title":"frequenz.api.weather.weather_pb2_grpc.WeatherForecastServiceServicer","text":"<p>             Bases: <code>object</code></p> <p>Service provides operations related to retrieving weather forecasts for locations.</p> <p>The forecasts are updated regularly, and the service will stream the latest available data unless a specific time range is requested.</p> <p>Note</p> <p>Weather forecasts are inherently uncertain and actual conditions may vary. Use the data responsibly.</p> Source code in <code>frequenz/api/weather/weather_pb2_grpc.py</code> <pre><code>class WeatherForecastServiceServicer(object):\n    \"\"\"Service provides operations related to retrieving weather forecasts for\n    locations.\n\n    The forecasts are updated regularly, and the service will stream the latest\n    available data unless a specific time range is requested.\n    !!! note\n    Weather forecasts are inherently uncertain and actual conditions may\n    vary. Use the data responsibly.\n    \"\"\"\n\n    def GetHistoricalWeatherForecast(self, request, context):\n        \"\"\"Returns historical weather forecast features for a geo location for a\n        specified time range.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def ReceiveLiveWeatherForecast(self, request, context):\n        \"\"\"Streams live weather forecast features for a geo location as they become\n        available. Initially, the most recent forecast will be streamed.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/weather/weather_pb2_grpc/#frequenz.api.weather.weather_pb2_grpc.WeatherForecastServiceServicer-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/api/weather/weather_pb2_grpc/#frequenz.api.weather.weather_pb2_grpc.WeatherForecastServiceServicer.GetHistoricalWeatherForecast","title":"GetHistoricalWeatherForecast","text":"<pre><code>GetHistoricalWeatherForecast(\n    request: frequenz.api.weather.weather_pb2.GetHistoricalWeatherForecastRequest,\n    context: _ServicerContext,\n) -&gt; typing.Union[\n    frequenz.api.weather.weather_pb2.GetHistoricalWeatherForecastResponse,\n    collections.abc.Awaitable[\n        frequenz.api.weather.weather_pb2.GetHistoricalWeatherForecastResponse\n    ],\n]\n</code></pre> <p>Returns historical weather forecast features for a geo location for a specified time range.</p> Source code in <code>frequenz/api/weather/weather_pb2_grpc.py</code> <pre><code>def GetHistoricalWeatherForecast(self, request, context):\n    \"\"\"Returns historical weather forecast features for a geo location for a\n    specified time range.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/weather/weather_pb2_grpc/#frequenz.api.weather.weather_pb2_grpc.WeatherForecastServiceServicer.ReceiveLiveWeatherForecast","title":"ReceiveLiveWeatherForecast","text":"<pre><code>ReceiveLiveWeatherForecast(\n    request: frequenz.api.weather.weather_pb2.ReceiveLiveWeatherForecastRequest,\n    context: _ServicerContext,\n) -&gt; typing.Union[\n    collections.abc.Iterator[\n        frequenz.api.weather.weather_pb2.ReceiveLiveWeatherForecastResponse\n    ],\n    collections.abc.AsyncIterator[\n        frequenz.api.weather.weather_pb2.ReceiveLiveWeatherForecastResponse\n    ],\n]\n</code></pre> <p>Streams live weather forecast features for a geo location as they become available. Initially, the most recent forecast will be streamed.</p> Source code in <code>frequenz/api/weather/weather_pb2_grpc.py</code> <pre><code>def ReceiveLiveWeatherForecast(self, request, context):\n    \"\"\"Streams live weather forecast features for a geo location as they become\n    available. Initially, the most recent forecast will be streamed.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/weather/weather_pb2_grpc/#frequenz.api.weather.weather_pb2_grpc.WeatherForecastServiceStub","title":"frequenz.api.weather.weather_pb2_grpc.WeatherForecastServiceStub","text":"<p>             Bases: <code>object</code></p> <p>Service provides operations related to retrieving weather forecasts for locations.</p> <p>The forecasts are updated regularly, and the service will stream the latest available data unless a specific time range is requested.</p> <p>Note</p> <p>Weather forecasts are inherently uncertain and actual conditions may vary. Use the data responsibly.</p> Source code in <code>frequenz/api/weather/weather_pb2_grpc.py</code> <pre><code>class WeatherForecastServiceStub(object):\n    \"\"\"Service provides operations related to retrieving weather forecasts for\n    locations.\n\n    The forecasts are updated regularly, and the service will stream the latest\n    available data unless a specific time range is requested.\n    !!! note\n    Weather forecasts are inherently uncertain and actual conditions may\n    vary. Use the data responsibly.\n    \"\"\"\n\n    def __init__(self, channel):\n        \"\"\"Constructor.\n\n        Args:\n            channel: A grpc.Channel.\n        \"\"\"\n        self.GetHistoricalWeatherForecast = channel.unary_unary(\n                '/frequenz.api.weatherforecast.v1.WeatherForecastService/GetHistoricalWeatherForecast',\n                request_serializer=frequenz_dot_api_dot_weather_dot_weather__pb2.GetHistoricalWeatherForecastRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_weather_dot_weather__pb2.GetHistoricalWeatherForecastResponse.FromString,\n                )\n        self.ReceiveLiveWeatherForecast = channel.unary_stream(\n                '/frequenz.api.weatherforecast.v1.WeatherForecastService/ReceiveLiveWeatherForecast',\n                request_serializer=frequenz_dot_api_dot_weather_dot_weather__pb2.ReceiveLiveWeatherForecastRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_weather_dot_weather__pb2.ReceiveLiveWeatherForecastResponse.FromString,\n                )\n</code></pre>"},{"location":"python-reference/frequenz/api/weather/weather_pb2_grpc/#frequenz.api.weather.weather_pb2_grpc.WeatherForecastServiceStub-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/weather/weather_pb2_grpc/#frequenz.api.weather.weather_pb2_grpc.WeatherForecastServiceStub.GetHistoricalWeatherForecast","title":"GetHistoricalWeatherForecast  <code>instance-attribute</code>","text":"<pre><code>GetHistoricalWeatherForecast: grpc.UnaryUnaryMultiCallable[\n    frequenz.api.weather.weather_pb2.GetHistoricalWeatherForecastRequest,\n    frequenz.api.weather.weather_pb2.GetHistoricalWeatherForecastResponse,\n] = channel.unary_unary(\n    \"/frequenz.api.weatherforecast.v1.WeatherForecastService/GetHistoricalWeatherForecast\",\n    request_serializer=frequenz_dot_api_dot_weather_dot_weather__pb2.GetHistoricalWeatherForecastRequest.SerializeToString,\n    response_deserializer=frequenz_dot_api_dot_weather_dot_weather__pb2.GetHistoricalWeatherForecastResponse.FromString,\n)\n</code></pre> <p>Returns historical weather forecast features for a geo location for a specified time range.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2_grpc/#frequenz.api.weather.weather_pb2_grpc.WeatherForecastServiceStub.ReceiveLiveWeatherForecast","title":"ReceiveLiveWeatherForecast  <code>instance-attribute</code>","text":"<pre><code>ReceiveLiveWeatherForecast: grpc.UnaryStreamMultiCallable[\n    frequenz.api.weather.weather_pb2.ReceiveLiveWeatherForecastRequest,\n    frequenz.api.weather.weather_pb2.ReceiveLiveWeatherForecastResponse,\n] = channel.unary_stream(\n    \"/frequenz.api.weatherforecast.v1.WeatherForecastService/ReceiveLiveWeatherForecast\",\n    request_serializer=frequenz_dot_api_dot_weather_dot_weather__pb2.ReceiveLiveWeatherForecastRequest.SerializeToString,\n    response_deserializer=frequenz_dot_api_dot_weather_dot_weather__pb2.ReceiveLiveWeatherForecastResponse.FromString,\n)\n</code></pre> <p>Streams live weather forecast features for a geo location as they become available. Initially, the most recent forecast will be streamed.</p>"},{"location":"python-reference/frequenz/api/weather/weather_pb2_grpc/#frequenz.api.weather.weather_pb2_grpc.WeatherForecastServiceStub-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/api/weather/weather_pb2_grpc/#frequenz.api.weather.weather_pb2_grpc.WeatherForecastServiceStub.__init__","title":"__init__","text":"<pre><code>__init__(\n    channel: typing.Union[grpc.Channel, grpc.aio.Channel]\n) -&gt; None\n</code></pre> <p>Constructor.</p> PARAMETER  DESCRIPTION <code>channel</code> <p>A grpc.Channel.</p> <p> TYPE: <code>Union[Channel, Channel]</code> </p> Source code in <code>frequenz/api/weather/weather_pb2_grpc.py</code> <pre><code>def __init__(self, channel):\n    \"\"\"Constructor.\n\n    Args:\n        channel: A grpc.Channel.\n    \"\"\"\n    self.GetHistoricalWeatherForecast = channel.unary_unary(\n            '/frequenz.api.weatherforecast.v1.WeatherForecastService/GetHistoricalWeatherForecast',\n            request_serializer=frequenz_dot_api_dot_weather_dot_weather__pb2.GetHistoricalWeatherForecastRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_weather_dot_weather__pb2.GetHistoricalWeatherForecastResponse.FromString,\n            )\n    self.ReceiveLiveWeatherForecast = channel.unary_stream(\n            '/frequenz.api.weatherforecast.v1.WeatherForecastService/ReceiveLiveWeatherForecast',\n            request_serializer=frequenz_dot_api_dot_weather_dot_weather__pb2.ReceiveLiveWeatherForecastRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_weather_dot_weather__pb2.ReceiveLiveWeatherForecastResponse.FromString,\n            )\n</code></pre>"},{"location":"python-reference/frequenz/client/weather/","title":"weather","text":""},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather","title":"frequenz.client.weather","text":"<p>The Weather Forecast API client.</p>"},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.Client","title":"frequenz.client.weather.Client","text":"<p>Weather forecast client.</p> Source code in <code>frequenz/client/weather/_client.py</code> <pre><code>class Client:\n    \"\"\"Weather forecast client.\"\"\"\n\n    def __init__(self, grpc_channel: grpc.aio.Channel, svc_addr: str) -&gt; None:\n        \"\"\"Initialize the client.\n\n        Args:\n            grpc_channel: gRPC channel to use for communication with the API.\n            svc_addr: Address of the service to connect to.\n        \"\"\"\n        self._svc_addr = svc_addr\n        self._stub = weather_pb2_grpc.WeatherForecastServiceStub(grpc_channel)\n        self._streams: dict[\n            tuple[Location | ForecastFeature, ...],\n            GrpcStreamingHelper[\n                weather_pb2.ReceiveLiveWeatherForecastResponse, Forecasts\n            ],\n        ] = {}\n\n    async def stream_live_forecast(\n        self,\n        locations: list[Location],\n        features: list[ForecastFeature],\n    ) -&gt; Receiver[Forecasts]:\n        \"\"\"Stream live weather forecast data.\n\n        Args:\n            locations: locations to stream data for.\n            features: features to stream data for.\n\n        Returns:\n            A channel receiver for weather forecast data.\n        \"\"\"\n        stream_key = tuple(tuple(locations) + tuple(features))\n\n        if stream_key not in self._streams:\n            self._streams[stream_key] = GrpcStreamingHelper(\n                f\"weather-forecast-{stream_key}\",\n                lambda: self._stub.ReceiveLiveWeatherForecast(  # type:ignore\n                    weather_pb2.ReceiveLiveWeatherForecastRequest(\n                        locations=(location.to_pb() for location in locations),\n                        features=(feature.value for feature in features),\n                    )\n                ),\n                Forecasts.from_pb,\n            )\n        return self._streams[stream_key].new_receiver()\n</code></pre>"},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.Client-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.Client.__init__","title":"__init__","text":"<pre><code>__init__(\n    grpc_channel: grpc.aio.Channel, svc_addr: str\n) -&gt; None\n</code></pre> <p>Initialize the client.</p> PARAMETER  DESCRIPTION <code>grpc_channel</code> <p>gRPC channel to use for communication with the API.</p> <p> TYPE: <code>Channel</code> </p> <code>svc_addr</code> <p>Address of the service to connect to.</p> <p> TYPE: <code>str</code> </p> Source code in <code>frequenz/client/weather/_client.py</code> <pre><code>def __init__(self, grpc_channel: grpc.aio.Channel, svc_addr: str) -&gt; None:\n    \"\"\"Initialize the client.\n\n    Args:\n        grpc_channel: gRPC channel to use for communication with the API.\n        svc_addr: Address of the service to connect to.\n    \"\"\"\n    self._svc_addr = svc_addr\n    self._stub = weather_pb2_grpc.WeatherForecastServiceStub(grpc_channel)\n    self._streams: dict[\n        tuple[Location | ForecastFeature, ...],\n        GrpcStreamingHelper[\n            weather_pb2.ReceiveLiveWeatherForecastResponse, Forecasts\n        ],\n    ] = {}\n</code></pre>"},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.Client.stream_live_forecast","title":"stream_live_forecast  <code>async</code>","text":"<pre><code>stream_live_forecast(\n    locations: list[Location],\n    features: list[ForecastFeature],\n) -&gt; Receiver[Forecasts]\n</code></pre> <p>Stream live weather forecast data.</p> PARAMETER  DESCRIPTION <code>locations</code> <p>locations to stream data for.</p> <p> TYPE: <code>list[Location]</code> </p> <code>features</code> <p>features to stream data for.</p> <p> TYPE: <code>list[ForecastFeature]</code> </p> RETURNS DESCRIPTION <code>Receiver[Forecasts]</code> <p>A channel receiver for weather forecast data.</p> Source code in <code>frequenz/client/weather/_client.py</code> <pre><code>async def stream_live_forecast(\n    self,\n    locations: list[Location],\n    features: list[ForecastFeature],\n) -&gt; Receiver[Forecasts]:\n    \"\"\"Stream live weather forecast data.\n\n    Args:\n        locations: locations to stream data for.\n        features: features to stream data for.\n\n    Returns:\n        A channel receiver for weather forecast data.\n    \"\"\"\n    stream_key = tuple(tuple(locations) + tuple(features))\n\n    if stream_key not in self._streams:\n        self._streams[stream_key] = GrpcStreamingHelper(\n            f\"weather-forecast-{stream_key}\",\n            lambda: self._stub.ReceiveLiveWeatherForecast(  # type:ignore\n                weather_pb2.ReceiveLiveWeatherForecastRequest(\n                    locations=(location.to_pb() for location in locations),\n                    features=(feature.value for feature in features),\n                )\n            ),\n            Forecasts.from_pb,\n        )\n    return self._streams[stream_key].new_receiver()\n</code></pre>"},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.ForecastFeature","title":"frequenz.client.weather.ForecastFeature","text":"<p>             Bases: <code>Enum</code></p> <p>Weather forecast features available through the API.</p> Source code in <code>frequenz/client/weather/_types.py</code> <pre><code>class ForecastFeature(enum.Enum):\n    \"\"\"Weather forecast features available through the API.\"\"\"\n\n    UNSPECIFIED = weather_pb2.ForecastFeature.FORECAST_FEATURE_UNSPECIFIED\n    \"\"\"Unspecified forecast feature.\"\"\"\n\n    U_WIND_COMPONENT_100_METRE = (\n        weather_pb2.ForecastFeature.FORECAST_FEATURE_U_WIND_COMPONENT_100_METRE\n    )\n    \"\"\"Eastward wind component at 100m altitude.\"\"\"\n\n    V_WIND_COMPONENT_100_METRE = (\n        weather_pb2.ForecastFeature.FORECAST_FEATURE_V_WIND_COMPONENT_100_METRE\n    )\n    \"\"\"Northward wind component at 100m altitude.\"\"\"\n\n    SURFACE_SOLAR_RADIATION_DOWNWARDS = (\n        weather_pb2.ForecastFeature.FORECAST_FEATURE_SURFACE_SOLAR_RADIATION_DOWNWARDS\n    )\n    \"\"\"Surface solar radiation downwards.\"\"\"\n\n    SURFACE_NET_SOLAR_RADIATION = (\n        weather_pb2.ForecastFeature.FORECAST_FEATURE_SURFACE_NET_SOLAR_RADIATION\n    )\n    \"\"\"Surface net solar radiation.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, forecast_feature: weather_pb2.ForecastFeature.ValueType\n    ) -&gt; ForecastFeature:\n        \"\"\"Convert a protobuf ForecastFeature value to ForecastFeature enum.\n\n        Args:\n            forecast_feature: protobuf forecast feature to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(t.value == forecast_feature for t in ForecastFeature):\n            _logger.warning(\n                \"Unknown forecast feature %s. Returning UNSPECIFIED.\", forecast_feature\n            )\n            return cls.UNSPECIFIED\n\n        return ForecastFeature(forecast_feature)\n</code></pre>"},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.ForecastFeature-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.ForecastFeature.SURFACE_NET_SOLAR_RADIATION","title":"SURFACE_NET_SOLAR_RADIATION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SURFACE_NET_SOLAR_RADIATION = (\n    weather_pb2.ForecastFeature.FORECAST_FEATURE_SURFACE_NET_SOLAR_RADIATION\n)\n</code></pre> <p>Surface net solar radiation.</p>"},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.ForecastFeature.SURFACE_SOLAR_RADIATION_DOWNWARDS","title":"SURFACE_SOLAR_RADIATION_DOWNWARDS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SURFACE_SOLAR_RADIATION_DOWNWARDS = (\n    weather_pb2.ForecastFeature.FORECAST_FEATURE_SURFACE_SOLAR_RADIATION_DOWNWARDS\n)\n</code></pre> <p>Surface solar radiation downwards.</p>"},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.ForecastFeature.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = (\n    weather_pb2.ForecastFeature.FORECAST_FEATURE_UNSPECIFIED\n)\n</code></pre> <p>Unspecified forecast feature.</p>"},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.ForecastFeature.U_WIND_COMPONENT_100_METRE","title":"U_WIND_COMPONENT_100_METRE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>U_WIND_COMPONENT_100_METRE = (\n    weather_pb2.ForecastFeature.FORECAST_FEATURE_U_WIND_COMPONENT_100_METRE\n)\n</code></pre> <p>Eastward wind component at 100m altitude.</p>"},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.ForecastFeature.V_WIND_COMPONENT_100_METRE","title":"V_WIND_COMPONENT_100_METRE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>V_WIND_COMPONENT_100_METRE = (\n    weather_pb2.ForecastFeature.FORECAST_FEATURE_V_WIND_COMPONENT_100_METRE\n)\n</code></pre> <p>Northward wind component at 100m altitude.</p>"},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.ForecastFeature-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.ForecastFeature.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(\n    forecast_feature: weather_pb2.ForecastFeature.ValueType,\n) -&gt; ForecastFeature\n</code></pre> <p>Convert a protobuf ForecastFeature value to ForecastFeature enum.</p> PARAMETER  DESCRIPTION <code>forecast_feature</code> <p>protobuf forecast feature to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>ForecastFeature</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/weather/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, forecast_feature: weather_pb2.ForecastFeature.ValueType\n) -&gt; ForecastFeature:\n    \"\"\"Convert a protobuf ForecastFeature value to ForecastFeature enum.\n\n    Args:\n        forecast_feature: protobuf forecast feature to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(t.value == forecast_feature for t in ForecastFeature):\n        _logger.warning(\n            \"Unknown forecast feature %s. Returning UNSPECIFIED.\", forecast_feature\n        )\n        return cls.UNSPECIFIED\n\n    return ForecastFeature(forecast_feature)\n</code></pre>"},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.Forecasts","title":"frequenz.client.weather.Forecasts  <code>dataclass</code>","text":"<p>Weather forecast data.</p> Source code in <code>frequenz/client/weather/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass Forecasts:\n    \"\"\"Weather forecast data.\"\"\"\n\n    _forecasts_pb: weather_pb2.ReceiveLiveWeatherForecastResponse\n\n    @classmethod\n    def from_pb(\n        cls, forecasts: weather_pb2.ReceiveLiveWeatherForecastResponse\n    ) -&gt; Forecasts:\n        \"\"\"Convert a protobuf Forecast message to Forecast object.\n\n        Args:\n            forecasts: protobuf message with live forecast data.\n\n        Returns:\n            Forecast object corresponding to the protobuf message.\n        \"\"\"\n        return cls(_forecasts_pb=forecasts)\n\n    # pylint: disable=too-many-locals,too-many-branches,too-many-statements\n    def to_ndarray_vlf(\n        self,\n        validity_times: list[dt.timedelta] | None = None,\n        locations: list[Location] | None = None,\n        features: list[ForecastFeature] | None = None,\n    ) -&gt; np.ndarray[\n        # the shape is known to be 3 dimensional, but the length of each dimension is\n        # not fixed, so we use typing.Any, instead of the usual const generic\n        # parameters.\n        tuple[typing.Any, typing.Any, typing.Any],\n        np.dtype[np.float64],\n    ]:\n        \"\"\"Convert a Forecast object to numpy array and use NaN to mark irrelevant data.\n\n        If any of the filters are None, all values for that parameter will be returned.\n\n        Args:\n            validity_times: The validity times to filter by.\n            locations: The locations to filter by.\n            features: The features to filter by.\n\n        Returns:\n            Numpy array of shape (num_validity_times, num_locations, num_features)\n\n        Raises:\n            ValueError: If the forecasts data is missing or invalid.\n        \"\"\"\n        # check for empty forecasts data\n        if not self._forecasts_pb.location_forecasts:\n            raise ValueError(\"Forecast data is missing or invalid.\")\n\n        try:\n            num_times = len(self._forecasts_pb.location_forecasts[0].forecasts)\n            num_locations = len(self._forecasts_pb.location_forecasts)\n            num_features = len(\n                self._forecasts_pb.location_forecasts[0].forecasts[0].features\n            )\n\n            # Look for the proto indexes of the filtered times, locations and features\n            location_indexes = []\n            validity_times_indexes = []\n            feature_indexes = []\n\n            # get the creation timestamp for calculating the validity timedeltas\n            creation_ts = self._forecasts_pb.location_forecasts[\n                0\n            ].creation_ts.ToDatetime()\n\n            # get the location indexes of the proto for the filtered locations\n            if locations:\n                for location in locations:\n                    for l_index, location_forecast in enumerate(\n                        self._forecasts_pb.location_forecasts\n                    ):\n                        if location == Location.from_pb(location_forecast.location):\n                            location_indexes.append(l_index)\n                            break\n            else:\n                location_indexes = list(range(num_locations))\n\n            # get the val indexes of the proto for the filtered validity times\n            if validity_times:\n                for req_validitiy_time in validity_times:\n                    for t_index, val_time in enumerate(\n                        self._forecasts_pb.location_forecasts[0].forecasts\n                    ):\n                        if req_validitiy_time == (\n                            val_time.valid_at_ts.ToDatetime() - creation_ts\n                        ):\n                            validity_times_indexes.append(t_index)\n                            break\n            else:\n                validity_times_indexes = list(range(num_times))\n\n            # get the feature indexes of the proto for the filtered features\n            if features:\n                for req_feature in features:\n                    for f_index, feature in enumerate(\n                        self._forecasts_pb.location_forecasts[0].forecasts[0].features\n                    ):\n                        if req_feature == ForecastFeature.from_pb(feature.feature):\n                            feature_indexes.append(f_index)\n                            break\n            else:\n                feature_indexes = list(range(num_features))\n\n            array = np.full(\n                (\n                    len(validity_times_indexes),\n                    len(location_indexes),\n                    len(feature_indexes),\n                ),\n                np.nan,\n            )\n\n            array_l_index = 0\n\n            for l_index in location_indexes:\n                array_t_index = 0\n\n                for t_index in validity_times_indexes:\n                    array_f_index = 0\n\n                    for f_index in feature_indexes:\n                        array[array_t_index, array_l_index, array_f_index] = (\n                            self._forecasts_pb.location_forecasts[l_index]\n                            .forecasts[t_index]\n                            .features[f_index]\n                            .value\n                        )\n                        array_f_index += 1\n\n                    array_t_index += 1\n\n                array_l_index += 1\n\n            # Check if the array shape matches the number of filtered times, locations\n            # and features\n            if array.shape[0] != len(validity_times_indexes):\n                print(\n                    f\"Warning:  The count of validity times in the \"\n                    f\"array({array.shape[0]}) does not match the expected time \"\n                    f\"filter count ({validity_times_indexes}.\"\n                )\n            if array.shape[1] != len(location_indexes):\n                print(\n                    f\"Warning:  The count of location in the \"\n                    f\"array ({array.shape[1]}) does not match the expected location \"\n                    f\"filter count ({location_indexes}).\"\n                )\n            if array.shape[2] != len(feature_indexes):\n                print(\n                    f\"Warning: The count of features ({array.shape[2]}) does not \"\n                    f\"match the feature filter count ({feature_indexes}).\"\n                )\n\n        # catch all exceptions\n        except Exception as e:\n            raise RuntimeError(\"Error processing forecast data\") from e\n\n        return array\n</code></pre>"},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.Forecasts-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.Forecasts.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(\n    forecasts: weather_pb2.ReceiveLiveWeatherForecastResponse,\n) -&gt; Forecasts\n</code></pre> <p>Convert a protobuf Forecast message to Forecast object.</p> PARAMETER  DESCRIPTION <code>forecasts</code> <p>protobuf message with live forecast data.</p> <p> TYPE: <code>ReceiveLiveWeatherForecastResponse</code> </p> RETURNS DESCRIPTION <code>Forecasts</code> <p>Forecast object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/weather/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, forecasts: weather_pb2.ReceiveLiveWeatherForecastResponse\n) -&gt; Forecasts:\n    \"\"\"Convert a protobuf Forecast message to Forecast object.\n\n    Args:\n        forecasts: protobuf message with live forecast data.\n\n    Returns:\n        Forecast object corresponding to the protobuf message.\n    \"\"\"\n    return cls(_forecasts_pb=forecasts)\n</code></pre>"},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.Forecasts.to_ndarray_vlf","title":"to_ndarray_vlf","text":"<pre><code>to_ndarray_vlf(\n    validity_times: list[dt.timedelta] | None = None,\n    locations: list[Location] | None = None,\n    features: list[ForecastFeature] | None = None,\n) -&gt; np.ndarray[\n    tuple[typing.Any, typing.Any, typing.Any],\n    np.dtype[np.float64],\n]\n</code></pre> <p>Convert a Forecast object to numpy array and use NaN to mark irrelevant data.</p> <p>If any of the filters are None, all values for that parameter will be returned.</p> PARAMETER  DESCRIPTION <code>validity_times</code> <p>The validity times to filter by.</p> <p> TYPE: <code>list[timedelta] | None</code> DEFAULT: <code>None</code> </p> <code>locations</code> <p>The locations to filter by.</p> <p> TYPE: <code>list[Location] | None</code> DEFAULT: <code>None</code> </p> <code>features</code> <p>The features to filter by.</p> <p> TYPE: <code>list[ForecastFeature] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ndarray[tuple[Any, Any, Any], dtype[float64]]</code> <p>Numpy array of shape (num_validity_times, num_locations, num_features)</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the forecasts data is missing or invalid.</p> Source code in <code>frequenz/client/weather/_types.py</code> <pre><code>def to_ndarray_vlf(\n    self,\n    validity_times: list[dt.timedelta] | None = None,\n    locations: list[Location] | None = None,\n    features: list[ForecastFeature] | None = None,\n) -&gt; np.ndarray[\n    # the shape is known to be 3 dimensional, but the length of each dimension is\n    # not fixed, so we use typing.Any, instead of the usual const generic\n    # parameters.\n    tuple[typing.Any, typing.Any, typing.Any],\n    np.dtype[np.float64],\n]:\n    \"\"\"Convert a Forecast object to numpy array and use NaN to mark irrelevant data.\n\n    If any of the filters are None, all values for that parameter will be returned.\n\n    Args:\n        validity_times: The validity times to filter by.\n        locations: The locations to filter by.\n        features: The features to filter by.\n\n    Returns:\n        Numpy array of shape (num_validity_times, num_locations, num_features)\n\n    Raises:\n        ValueError: If the forecasts data is missing or invalid.\n    \"\"\"\n    # check for empty forecasts data\n    if not self._forecasts_pb.location_forecasts:\n        raise ValueError(\"Forecast data is missing or invalid.\")\n\n    try:\n        num_times = len(self._forecasts_pb.location_forecasts[0].forecasts)\n        num_locations = len(self._forecasts_pb.location_forecasts)\n        num_features = len(\n            self._forecasts_pb.location_forecasts[0].forecasts[0].features\n        )\n\n        # Look for the proto indexes of the filtered times, locations and features\n        location_indexes = []\n        validity_times_indexes = []\n        feature_indexes = []\n\n        # get the creation timestamp for calculating the validity timedeltas\n        creation_ts = self._forecasts_pb.location_forecasts[\n            0\n        ].creation_ts.ToDatetime()\n\n        # get the location indexes of the proto for the filtered locations\n        if locations:\n            for location in locations:\n                for l_index, location_forecast in enumerate(\n                    self._forecasts_pb.location_forecasts\n                ):\n                    if location == Location.from_pb(location_forecast.location):\n                        location_indexes.append(l_index)\n                        break\n        else:\n            location_indexes = list(range(num_locations))\n\n        # get the val indexes of the proto for the filtered validity times\n        if validity_times:\n            for req_validitiy_time in validity_times:\n                for t_index, val_time in enumerate(\n                    self._forecasts_pb.location_forecasts[0].forecasts\n                ):\n                    if req_validitiy_time == (\n                        val_time.valid_at_ts.ToDatetime() - creation_ts\n                    ):\n                        validity_times_indexes.append(t_index)\n                        break\n        else:\n            validity_times_indexes = list(range(num_times))\n\n        # get the feature indexes of the proto for the filtered features\n        if features:\n            for req_feature in features:\n                for f_index, feature in enumerate(\n                    self._forecasts_pb.location_forecasts[0].forecasts[0].features\n                ):\n                    if req_feature == ForecastFeature.from_pb(feature.feature):\n                        feature_indexes.append(f_index)\n                        break\n        else:\n            feature_indexes = list(range(num_features))\n\n        array = np.full(\n            (\n                len(validity_times_indexes),\n                len(location_indexes),\n                len(feature_indexes),\n            ),\n            np.nan,\n        )\n\n        array_l_index = 0\n\n        for l_index in location_indexes:\n            array_t_index = 0\n\n            for t_index in validity_times_indexes:\n                array_f_index = 0\n\n                for f_index in feature_indexes:\n                    array[array_t_index, array_l_index, array_f_index] = (\n                        self._forecasts_pb.location_forecasts[l_index]\n                        .forecasts[t_index]\n                        .features[f_index]\n                        .value\n                    )\n                    array_f_index += 1\n\n                array_t_index += 1\n\n            array_l_index += 1\n\n        # Check if the array shape matches the number of filtered times, locations\n        # and features\n        if array.shape[0] != len(validity_times_indexes):\n            print(\n                f\"Warning:  The count of validity times in the \"\n                f\"array({array.shape[0]}) does not match the expected time \"\n                f\"filter count ({validity_times_indexes}.\"\n            )\n        if array.shape[1] != len(location_indexes):\n            print(\n                f\"Warning:  The count of location in the \"\n                f\"array ({array.shape[1]}) does not match the expected location \"\n                f\"filter count ({location_indexes}).\"\n            )\n        if array.shape[2] != len(feature_indexes):\n            print(\n                f\"Warning: The count of features ({array.shape[2]}) does not \"\n                f\"match the feature filter count ({feature_indexes}).\"\n            )\n\n    # catch all exceptions\n    except Exception as e:\n        raise RuntimeError(\"Error processing forecast data\") from e\n\n    return array\n</code></pre>"},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.Location","title":"frequenz.client.weather.Location  <code>dataclass</code>","text":"<p>Location data.</p> ATTRIBUTE DESCRIPTION <code>latitude</code> <p>latitude of the location.</p> <p> TYPE: <code>float</code> </p> <code>longitude</code> <p>longitude of the location.</p> <p> TYPE: <code>float</code> </p> <code>country_code</code> <p>ISO 3166-1 alpha-2 country code of the location.</p> <p> TYPE: <code>str</code> </p> Source code in <code>frequenz/client/weather/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass Location:\n    \"\"\"Location data.\n\n    Attributes:\n        latitude: latitude of the location.\n        longitude: longitude of the location.\n        country_code: ISO 3166-1 alpha-2 country code of the location.\n    \"\"\"\n\n    latitude: float\n    longitude: float\n    country_code: str\n\n    @classmethod\n    def from_pb(cls, location: location_pb2.Location) -&gt; Location:\n        \"\"\"Convert a protobuf Location message to Location object.\n\n        Args:\n            location: protobuf location to convert.\n\n        Returns:\n            Location object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            latitude=location.latitude,\n            longitude=location.longitude,\n            country_code=location.country_code,\n        )\n\n    def to_pb(self) -&gt; location_pb2.Location:\n        \"\"\"Convert a Location object to protobuf Location message.\n\n        Returns:\n            Protobuf message corresponding to the Location object.\n        \"\"\"\n        return location_pb2.Location(\n            latitude=self.latitude,\n            longitude=self.longitude,\n            country_code=self.country_code,\n        )\n</code></pre>"},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.Location-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.Location.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(location: location_pb2.Location) -&gt; Location\n</code></pre> <p>Convert a protobuf Location message to Location object.</p> PARAMETER  DESCRIPTION <code>location</code> <p>protobuf location to convert.</p> <p> TYPE: <code>Location</code> </p> RETURNS DESCRIPTION <code>Location</code> <p>Location object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/weather/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, location: location_pb2.Location) -&gt; Location:\n    \"\"\"Convert a protobuf Location message to Location object.\n\n    Args:\n        location: protobuf location to convert.\n\n    Returns:\n        Location object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        latitude=location.latitude,\n        longitude=location.longitude,\n        country_code=location.country_code,\n    )\n</code></pre>"},{"location":"python-reference/frequenz/client/weather/#frequenz.client.weather.Location.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; location_pb2.Location\n</code></pre> <p>Convert a Location object to protobuf Location message.</p> RETURNS DESCRIPTION <code>Location</code> <p>Protobuf message corresponding to the Location object.</p> Source code in <code>frequenz/client/weather/_types.py</code> <pre><code>def to_pb(self) -&gt; location_pb2.Location:\n    \"\"\"Convert a Location object to protobuf Location message.\n\n    Returns:\n        Protobuf message corresponding to the Location object.\n    \"\"\"\n    return location_pb2.Location(\n        latitude=self.latitude,\n        longitude=self.longitude,\n        country_code=self.country_code,\n    )\n</code></pre>"}]}